import tenseal as ts
import numpy as np

print(">>> [æ¨¡å—] ç²¾ç¡®æ•´æ•°è®¡ç®—ï¼šBFV æ–¹æ¡ˆæ¼”ç¤º (v0.3.16)")

# ==============================================================================
# 1. ç¯å¢ƒå‡†å¤‡ (Context Setup)
# ==============================================================================
# BFV çš„é…ç½®é€»è¾‘ä¸ CKKS ä¸åŒã€‚
# - ä¸éœ€è¦ global_scaleã€‚
# - éœ€è¦ plain_modulus: å†³å®šäº†æ•´æ•°ç¯çš„å¤§å°ã€‚
#   ä¾‹å¦‚ plain_modulus=1032193ï¼Œé‚£ä¹ˆæ‰€æœ‰è®¡ç®—ç»“æœéƒ½ä¼šå¯¹ 1032193 å–æ¨¡ã€‚
#   å¦‚æœä½ çš„ç´¯åŠ ç»“æœè¶…è¿‡è¿™ä¸ªæ•°ï¼Œå°±ä¼šå‘ç”Ÿæº¢å‡ºï¼ˆWrap-aroundï¼‰ã€‚

ctx = ts.context(
    ts.SCHEME_TYPE.BFV,
    poly_modulus_degree=4096,
    plain_modulus=1032193 # ä¸€ä¸ªä¼˜åŒ–çš„ç´ æ•°ï¼Œæ”¯æŒæ‰¹å¤„ç†
)

# ç”Ÿæˆå¯†é’¥
# BFV çš„ä¹˜æ³•åŒæ ·ä¼šå¢åŠ å¯†æ–‡å¤§å°ï¼Œéœ€è¦ Relin Keys
# BFV çš„èšåˆï¼ˆBatchingï¼‰éœ€è¦ Galois Keys
ctx.generate_galois_keys()
ctx.generate_relin_keys()

print(f"âœ… ç¯å¢ƒé…ç½®å®Œæˆ: Scheme=BFV, Plain Modulus={1032193}")


# ==============================================================================
# 2. åŸºç¡€æ•´æ•°è¿ç®— (Exact Arithmetic)
# ==============================================================================
print("\n--- A. åŸºç¡€æ•´æ•°è¿ç®— (æ— è¯¯å·®) ---")

# åˆ›å»ºæ•´æ•°å‘é‡
# å¿…é¡»ä½¿ç”¨ ts.bfv_vector
vec_a = ts.bfv_vector(ctx, [10, 20, 30])
vec_b = ts.bfv_vector(ctx, [1, 2, 3])

# 1. åŠ æ³•
res_add = vec_a + vec_b
print(f"åŠ æ³• (10+1...): {res_add.decrypt()}")

# 2. ä¹˜æ³•
res_mul = vec_a * vec_b
print(f"ä¹˜æ³• (10*1...): {res_mul.decrypt()}")

# 3. å‡æ³•
res_sub = vec_a - vec_b
print(f"å‡æ³• (10-1...): {res_sub.decrypt()}")

# 4. éªŒè¯ç²¾ç¡®æ€§
# å¦‚æœæ˜¯ CKKSï¼Œè¿™é‡Œå¯èƒ½æ˜¯ 11.0000002
# BFV ä¿è¯ç»“æœä¸€å®šæ˜¯æ•´æ•° 11
if res_add.decrypt()[0] == 11:
    print("âœ… éªŒè¯é€šè¿‡: ç»“æœæ˜¯ç²¾ç¡®æ•´æ•°")
else:
    print("âŒ éªŒè¯å¤±è´¥")


# ==============================================================================
# 3. ç”µå­æŠ•ç¥¨æ¨¡æ‹Ÿ (E-Voting Simulation)
# ==============================================================================
print("\n--- B. éšç§ç”µå­æŠ•ç¥¨æ¨¡æ‹Ÿ ---")
# åœºæ™¯ï¼š3 ä¸ªé€‰æ°‘ï¼Œå¯¹ "å€™é€‰äºº A" è¿›è¡ŒæŠ•ç¥¨ã€‚
# 1 = åŒæ„, 0 = åå¯¹
# é€‰æ°‘çš„æ•°æ®åœ¨æœ¬åœ°åŠ å¯†ï¼Œäº‘ç«¯åªè´Ÿè´£ç»Ÿè®¡æ€»ç¥¨æ•°ï¼Œä¸çŸ¥é“è°æŠ•äº†è°ã€‚

# é€‰æ°‘æ•°æ® (æ˜æ–‡)
voter1_choice = [1]
voter2_choice = [0]
voter3_choice = [1]

# 1. é€‰æ°‘æœ¬åœ°åŠ å¯†
enc_v1 = ts.bfv_vector(ctx, voter1_choice)
enc_v2 = ts.bfv_vector(ctx, voter2_choice)
enc_v3 = ts.bfv_vector(ctx, voter3_choice)

print("é€‰æ°‘å·²å®ŒæˆåŠ å¯†æŠ•ç¥¨ã€‚äº‘ç«¯å¼€å§‹è®¡ç¥¨...")

# 2. äº‘ç«¯èšåˆ (Homomorphic Addition)
# ç±»ä¼¼äº Paillier ç®—æ³•ï¼Œå¯†æ–‡ç›¸åŠ  = æ˜æ–‡ç›¸åŠ 
enc_total_votes = enc_v1 + enc_v2 + enc_v3

# 3. å…¬å¸ƒç»“æœ (è§£å¯†)
final_count = enc_total_votes.decrypt()[0]

print(f"é€‰æ°‘ 1: ğŸ”’ (Secret)")
print(f"é€‰æ°‘ 2: ğŸ”’ (Secret)")
print(f"é€‰æ°‘ 3: ğŸ”’ (Secret)")
print(f"æœ€ç»ˆå¾—ç¥¨æ•°: {final_count} (é¢„æœŸ: 2)")


# ==============================================================================
# 4. é«˜çº§æŠ€å·§ï¼šæ‰¹å¤„ç†è®¡ç¥¨ (Batch Voting)
# ==============================================================================
print("\n--- C. æ‰¹å¤„ç†è®¡ç¥¨ (åŒæ—¶ç»Ÿè®¡å¤šä¸ªå€™é€‰äºº) ---")
# åœºæ™¯ï¼šä¸€æ¬¡æ€§ç»Ÿè®¡ å€™é€‰äººA, å€™é€‰äººB, å€™é€‰äººC çš„ç¥¨æ•°ã€‚
# å‘é‡åŒ–ï¼š[ç¥¨A, ç¥¨B, ç¥¨C]

# é€‰æ°‘ 1: æŠ•ç»™ A
vote_1 = [1, 0, 0]
# é€‰æ°‘ 2: æŠ•ç»™ B
vote_2 = [0, 1, 0]
# é€‰æ°‘ 3: æŠ•ç»™ A å’Œ C (å¤šé€‰)
vote_3 = [1, 0, 1]

# åŠ å¯†
enc_batch_1 = ts.bfv_vector(ctx, vote_1)
enc_batch_2 = ts.bfv_vector(ctx, vote_2)
enc_batch_3 = ts.bfv_vector(ctx, vote_3)

# èšåˆ
# ä½¿ç”¨åŸåœ°æ“ä½œ (add_) èŠ‚çœå†…å­˜
enc_batch_1.add_(enc_batch_2)
enc_batch_1.add_(enc_batch_3)

# ç»“æœ
# A: 1+0+1 = 2
# B: 0+1+0 = 1
# C: 0+0+1 = 1
results = enc_batch_1.decrypt()
print(f"å€™é€‰äºº A å¾—ç¥¨: {results[0]}")
print(f"å€™é€‰äºº B å¾—ç¥¨: {results[1]}")
print(f"å€™é€‰äºº C å¾—ç¥¨: {results[2]}")


# ==============================================================================
# 5. ä¹˜æ³•æ·±åº¦è­¦å‘Š (In-place Mul)
# ==============================================================================
print("\n--- D. BFV çš„ä¹˜æ³•é™åˆ¶ ---")
# BFV çš„ä¹˜æ³•ä¼šå¯¼è‡´å™ªå£°å¿«é€Ÿå¢é•¿ã€‚å¦‚æœä¸ä½¿ç”¨ Relinearizationï¼Œå¯†æ–‡å¤§å°ä¼šçˆ†ç‚¸ã€‚

small_ctx = ts.context(ts.SCHEME_TYPE.BFV, poly_modulus_degree=4096, plain_modulus=1032193)
# æ³¨æ„ï¼šè¿™é‡Œæ•…æ„ä¸ç”Ÿæˆ Relin Keysï¼Œæ¼”ç¤ºåæœ
# small_ctx.generate_relin_keys()

x = ts.bfv_vector(small_ctx, [2])
try:
    # å°è¯•è¿ç»­ä¹˜æ³•
    # ç¬¬ä¸€æ¬¡ä¹˜: size 2 -> 3
    # ç¬¬äºŒæ¬¡ä¹˜: size 3 -> 5 ... å¾ˆå¿«å°±ä¼šæŠ¥é”™æˆ–è€…ä¸å¯è§£å¯†
    for i in range(3):
        x = x * x
        print(f"ç¬¬ {i+1} æ¬¡å¹³æ–¹: å¯†æ–‡ Size = {x.size()}")
except ValueError as e:
    print(f"âŒ ä¹˜æ³•å¤±è´¥: {e}")
    print("ğŸ’¡ æç¤º: BFV åšä¹˜æ³•å¿…é¡»ç”Ÿæˆ Relin Keys å¹¶å¯ç”¨ auto_relin=True")