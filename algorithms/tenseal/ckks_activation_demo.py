import tenseal as ts
import numpy as np
import math

print(">>> [æ¨¡å—] éçº¿æ€§å‡½æ•°è¿‘ä¼¼æ¼”ç¤º (v0.3.16)")

# ==============================================================================
# 1. ç¯å¢ƒå‡†å¤‡ (Context Setup)
# ==============================================================================
# è¿‘ä¼¼å‡½æ•°é€šå¸¸éœ€è¦ x^3 æˆ– x^7ï¼Œè¿™æ„å‘³ç€éœ€è¦è¾ƒå¤§çš„ä¹˜æ³•æ·±åº¦ã€‚
# å¿…é¡»ä½¿ç”¨ Degree 16384 å’Œè¶³å¤Ÿçš„ä¸­é—´æ¨¡æ•° (40)ã€‚
ctx = ts.context(
    ts.SCHEME_TYPE.CKKS,
    poly_modulus_degree=16384,
    coeff_mod_bit_sizes=[60, 40, 40, 40, 60] # Depth = 3 (æ”¯æŒ x^3 ~ x^7 çš„ä¼˜åŒ–è®¡ç®—)
)
ctx.global_scale = 2**40
ctx.auto_relin = True
ctx.auto_rescale = True
# Polyval å†…éƒ¨ä¼šè°ƒç”¨åŠ æ³•å’Œä¹˜æ³•ï¼Œå› æ­¤éœ€è¦ Relin Keys
ctx.generate_relin_keys()

print(f"âœ… ç¯å¢ƒé…ç½®å®Œæˆ: Degree=16384, æ”¯æŒå¤šé¡¹å¼è¯„ä¼°")


# ==============================================================================
# 2. Sigmoid å‡½æ•°è¿‘ä¼¼ (The "Hello World" of HE-ML)
# ==============================================================================
print("\n--- A. Sigmoid å‡½æ•°è¿‘ä¼¼ ---")
# çœŸå® Sigmoid: f(x) = 1 / (1 + exp(-x))
# åŒæ€åŠ å¯†ä¸­å¸¸ç”¨è¿‘ä¼¼ (åœ¨ [-5, 5] èŒƒå›´å†…):
# f(x) â‰ˆ 0.5 + 0.197x - 0.004x^3
#
# ç³»æ•°åˆ—è¡¨æ ¼å¼ (å‡åºæ’åˆ—): [å¸¸æ•°é¡¹, x^1ç³»æ•°, x^2ç³»æ•°, x^3ç³»æ•°...]
sigmoid_coeffs = [0.5, 0.197, 0.0, -0.004]

# å‡†å¤‡è¾“å…¥æ•°æ®
input_data = [-5.0, -1.0, 0.0, 1.0, 5.0]
enc_input = ts.ckks_vector(ctx, input_data)

print(f"è¾“å…¥æ•°æ® (x): {input_data}")

# æ‰§è¡Œå¤šé¡¹å¼è¯„ä¼°
# API: polyval(coefficients)
enc_sigmoid = enc_input.polyval(sigmoid_coeffs)

# --- éªŒè¯ç¯èŠ‚ ---
# 1. è®¡ç®—åŠ å¯†ç»“æœ
he_result = enc_sigmoid.decrypt()

# 2. è®¡ç®—çœŸå® Sigmoid ç»“æœ (æ˜æ–‡)
real_result = [1 / (1 + math.exp(-x)) for x in input_data]

print("æ¯”è¾ƒç»“æœ:")
print(f"{'Input':<10} | {'HE Approx':<20} | {'Real Sigmoid':<20} | {'Diff'}")
print("-" * 65)
for x, he, real in zip(input_data, he_result, real_result):
    print(f"{x:<10.1f} | {he:<20.4f} | {real:<20.4f} | {abs(he-real):.4f}")

print("\nğŸ’¡ è§‚å¯Ÿ: åœ¨ x=0 é™„è¿‘éå¸¸ç²¾å‡†ï¼Œä½†åœ¨ x=Â±5 è¾¹ç¼˜å¤„è¯¯å·®å¢å¤§ã€‚è¿™æ˜¯å¤šé¡¹å¼è¿‘ä¼¼çš„ç‰¹æ€§ã€‚")
#


# ==============================================================================
# 3. ReLU å‡½æ•°è¿‘ä¼¼ (The Hard Part)
# ==============================================================================
print("\n--- B. ReLU å‡½æ•°è¿‘ä¼¼ ---")
# çœŸå® ReLU: f(x) = max(0, x)
# ReLU æ˜¯åˆ†æ®µçº¿æ€§çš„ï¼Œä¸æ˜¯å…‰æ»‘å‡½æ•°ï¼Œå¾ˆéš¾ç”¨å¤šé¡¹å¼å®Œç¾æ‹Ÿåˆã€‚
# ä¸šç•Œå¸¸ç”¨åšæ³•ï¼š
# 1. ä½¿ç”¨ x^2 (Square) ç›´æ¥æ›¿ä»£ ReLU (æ•ˆæœå¾€å¾€ä¸é”™)ã€‚
# 2. ä½¿ç”¨åŒºé—´å†…çš„å¤šé¡¹å¼æ‹Ÿåˆã€‚
#
# è¿™é‡Œæ¼”ç¤ºä¸€ä¸ªåœ¨ [-2, 2] åŒºé—´å†…çš„ 2 æ¬¡æ‹Ÿåˆ:
# f(x) â‰ˆ 0.44 + 0.5x + 0.11x^2
relu_coeffs = [0.44, 0.5, 0.11]

# å‡†å¤‡è¾“å…¥
relu_inputs = [-2.0, -1.0, 0.0, 1.0, 2.0]
enc_relu_in = ts.ckks_vector(ctx, relu_inputs)

# æ‰§è¡Œå¤šé¡¹å¼
enc_relu = enc_relu_in.polyval(relu_coeffs)

# --- éªŒè¯ç¯èŠ‚ ---
he_relu_res = enc_relu.decrypt()
real_relu_res = [max(0, x) for x in relu_inputs]

print("æ¯”è¾ƒç»“æœ (ReLU Approximated):")
print(f"{'Input':<10} | {'HE Approx':<20} | {'Real ReLU':<20}")
print("-" * 55)
for x, he, real in zip(relu_inputs, he_relu_res, real_relu_res):
    print(f"{x:<10.1f} | {he:<20.4f} | {real:<20.4f}")


# ==============================================================================
# 4. å¦ä¸€ç§é€‰æ‹©ï¼šå¹³æ–¹æ¿€æ´» (Square Activation)
# ==============================================================================
print("\n--- C. å¹³æ–¹æ¿€æ´» (æœ€å¿«æ–¹æ¡ˆ) ---")
# ç”±äº polyval è®¡ç®—é‡å¤§ä¸”æ¶ˆè€—æ·±åº¦ï¼Œå¾ˆå¤šåŠ å¯†ç¥ç»ç½‘ç»œç›´æ¥ä½¿ç”¨ f(x) = x^2 ä½œä¸ºæ¿€æ´»å‡½æ•°ã€‚
# å®ƒçš„éçº¿æ€§ç‰¹æ€§è¶³ä»¥æ”¯æŒç®€å•çš„åˆ†ç±»ä»»åŠ¡ (å¦‚ MNIST)ã€‚

enc_sq_in = ts.ckks_vector(ctx, [-2.0, 3.0])
# ä½¿ç”¨ .square() æå…¶é«˜æ•ˆï¼Œåªæ¶ˆè€— 1 å±‚æ·±åº¦
enc_sq_out = enc_sq_in.square()

print(f"è¾“å…¥: [-2.0, 3.0]")
print(f"å¹³æ–¹æ¿€æ´»è¾“å‡º: {enc_sq_out.decrypt()}")